import {
  __publicField
} from "./chunk-YBOLLQGG.js";

// node_modules/@easepick/bundle/dist/index.esm.js
var _t = class extends Date {
  constructor(e2 = null, i2 = "YYYY-MM-DD", n2 = "en-US") {
    super(_t.parseDateTime(e2, i2, n2));
    __publicField(this, "lang");
    this.lang = n2;
  }
  static parseDateTime(e2, i2 = "YYYY-MM-DD", n2 = "en-US") {
    if (!e2)
      return new Date(new Date().setHours(0, 0, 0, 0));
    if (e2 instanceof _t)
      return e2.toJSDate();
    if (e2 instanceof Date)
      return e2;
    if (/^-?\d{10,}$/.test(String(e2)))
      return new Date(Number(e2));
    if ("string" == typeof e2) {
      const s2 = [];
      let o2 = null;
      for (; null != (o2 = _t.regex.exec(i2)); )
        "\\" !== o2[1] && s2.push(o2);
      if (s2.length) {
        const i3 = { year: null, month: null, shortMonth: null, longMonth: null, day: null, hour: 0, minute: 0, second: 0, ampm: null, value: "" };
        s2[0].index > 0 && (i3.value += ".*?");
        for (const [e3, o4] of Object.entries(s2)) {
          const s3 = Number(e3), { group: a2, pattern: r2 } = _t.formatPatterns(o4[0], n2);
          i3[a2] = s3 + 1, i3.value += r2, i3.value += ".*?";
        }
        const o3 = new RegExp(`^${i3.value}$`);
        if (o3.test(e2)) {
          const s3 = o3.exec(e2), a2 = Number(s3[i3.year]);
          let r2 = null;
          i3.month ? r2 = Number(s3[i3.month]) - 1 : i3.shortMonth ? r2 = _t.shortMonths(n2).indexOf(s3[i3.shortMonth]) : i3.longMonth && (r2 = _t.longMonths(n2).indexOf(s3[i3.longMonth]));
          const c2 = Number(s3[i3.day]) || 1, l2 = Number(s3[i3.hour]);
          let h2 = Number.isNaN(l2) ? 0 : l2;
          const d2 = Number(s3[i3.minute]), p = Number.isNaN(d2) ? 0 : d2, u = Number(s3[i3.second]), g = Number.isNaN(u) ? 0 : u, m = s3[i3.ampm];
          return m && "PM" === m && (h2 += 12, 24 === h2 && (h2 = 0)), new Date(a2, r2, c2, h2, p, g, 0);
        }
      }
    }
    return new Date(new Date().setHours(0, 0, 0, 0));
  }
  static shortMonths(e2) {
    return _t.MONTH_JS.map((t2) => new Date(2019, t2).toLocaleString(e2, { month: "short" }));
  }
  static longMonths(e2) {
    return _t.MONTH_JS.map((t2) => new Date(2019, t2).toLocaleString(e2, { month: "long" }));
  }
  static formatPatterns(e2, i2) {
    switch (e2) {
      case "YY":
      case "YYYY":
        return { group: "year", pattern: `(\\d{${e2.length}})` };
      case "M":
        return { group: "month", pattern: "(\\d{1,2})" };
      case "MM":
        return { group: "month", pattern: "(\\d{2})" };
      case "MMM":
        return { group: "shortMonth", pattern: `(${_t.shortMonths(i2).join("|")})` };
      case "MMMM":
        return { group: "longMonth", pattern: `(${_t.longMonths(i2).join("|")})` };
      case "D":
        return { group: "day", pattern: "(\\d{1,2})" };
      case "DD":
        return { group: "day", pattern: "(\\d{2})" };
      case "h":
      case "H":
        return { group: "hour", pattern: "(\\d{1,2})" };
      case "hh":
      case "HH":
        return { group: "hour", pattern: "(\\d{2})" };
      case "m":
        return { group: "minute", pattern: "(\\d{1,2})" };
      case "mm":
        return { group: "minute", pattern: "(\\d{2})" };
      case "s":
        return { group: "second", pattern: "(\\d{1,2})" };
      case "ss":
        return { group: "second", pattern: "(\\d{2})" };
      case "a":
      case "A":
        return { group: "ampm", pattern: "(AM|PM|am|pm)" };
    }
  }
  getWeek(t2) {
    const e2 = new Date(this.midnight_ts(this)), i2 = (this.getDay() + (7 - t2)) % 7;
    e2.setDate(e2.getDate() - i2);
    const n2 = e2.getTime();
    return e2.setMonth(0, 1), e2.getDay() !== t2 && e2.setMonth(0, 1 + (4 - e2.getDay() + 7) % 7), 1 + Math.ceil((n2 - e2.getTime()) / 6048e5);
  }
  clone() {
    return new _t(this);
  }
  toJSDate() {
    return new Date(this);
  }
  inArray(t2, e2 = "[]") {
    return t2.some((t3) => t3 instanceof Array ? this.isBetween(t3[0], t3[1], e2) : this.isSame(t3, "day"));
  }
  isBetween(t2, e2, i2 = "()") {
    switch (i2) {
      default:
      case "()":
        return this.midnight_ts(this) > this.midnight_ts(t2) && this.midnight_ts(this) < this.midnight_ts(e2);
      case "[)":
        return this.midnight_ts(this) >= this.midnight_ts(t2) && this.midnight_ts(this) < this.midnight_ts(e2);
      case "(]":
        return this.midnight_ts(this) > this.midnight_ts(t2) && this.midnight_ts(this) <= this.midnight_ts(e2);
      case "[]":
        return this.midnight_ts() >= this.midnight_ts(t2) && this.midnight_ts() <= this.midnight_ts(e2);
    }
  }
  isBefore(t2, e2 = "days") {
    switch (e2) {
      case "day":
      case "days":
        return new Date(t2.getFullYear(), t2.getMonth(), t2.getDate()).getTime() > new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime();
      case "month":
      case "months":
        return new Date(t2.getFullYear(), t2.getMonth(), 1).getTime() > new Date(this.getFullYear(), this.getMonth(), 1).getTime();
      case "year":
      case "years":
        return t2.getFullYear() > this.getFullYear();
    }
    throw new Error("isBefore: Invalid unit!");
  }
  isSameOrBefore(t2, e2 = "days") {
    switch (e2) {
      case "day":
      case "days":
        return new Date(t2.getFullYear(), t2.getMonth(), t2.getDate()).getTime() >= new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime();
      case "month":
      case "months":
        return new Date(t2.getFullYear(), t2.getMonth(), 1).getTime() >= new Date(this.getFullYear(), this.getMonth(), 1).getTime();
    }
    throw new Error("isSameOrBefore: Invalid unit!");
  }
  isAfter(t2, e2 = "days") {
    switch (e2) {
      case "day":
      case "days":
        return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() > new Date(t2.getFullYear(), t2.getMonth(), t2.getDate()).getTime();
      case "month":
      case "months":
        return new Date(this.getFullYear(), this.getMonth(), 1).getTime() > new Date(t2.getFullYear(), t2.getMonth(), 1).getTime();
      case "year":
      case "years":
        return this.getFullYear() > t2.getFullYear();
    }
    throw new Error("isAfter: Invalid unit!");
  }
  isSameOrAfter(t2, e2 = "days") {
    switch (e2) {
      case "day":
      case "days":
        return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() >= new Date(t2.getFullYear(), t2.getMonth(), t2.getDate()).getTime();
      case "month":
      case "months":
        return new Date(this.getFullYear(), this.getMonth(), 1).getTime() >= new Date(t2.getFullYear(), t2.getMonth(), 1).getTime();
    }
    throw new Error("isSameOrAfter: Invalid unit!");
  }
  isSame(t2, e2 = "days") {
    switch (e2) {
      case "day":
      case "days":
        return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() === new Date(t2.getFullYear(), t2.getMonth(), t2.getDate()).getTime();
      case "month":
      case "months":
        return new Date(this.getFullYear(), this.getMonth(), 1).getTime() === new Date(t2.getFullYear(), t2.getMonth(), 1).getTime();
    }
    throw new Error("isSame: Invalid unit!");
  }
  add(t2, e2 = "days") {
    switch (e2) {
      case "day":
      case "days":
        this.setDate(this.getDate() + t2);
        break;
      case "month":
      case "months":
        this.setMonth(this.getMonth() + t2);
    }
    return this;
  }
  subtract(t2, e2 = "days") {
    switch (e2) {
      case "day":
      case "days":
        this.setDate(this.getDate() - t2);
        break;
      case "month":
      case "months":
        this.setMonth(this.getMonth() - t2);
    }
    return this;
  }
  diff(t2, e2 = "days") {
    switch (e2) {
      default:
      case "day":
      case "days":
        return Math.round((this.midnight_ts() - this.midnight_ts(t2)) / 864e5);
      case "month":
      case "months":
        let e3 = 12 * (t2.getFullYear() - this.getFullYear());
        return e3 -= t2.getMonth(), e3 += this.getMonth(), e3;
    }
  }
  format(e2, i2 = "en-US") {
    let n2 = "";
    const s2 = [];
    let o2 = null;
    for (; null != (o2 = _t.regex.exec(e2)); )
      "\\" !== o2[1] && s2.push(o2);
    if (s2.length) {
      s2[0].index > 0 && (n2 += e2.substring(0, s2[0].index));
      for (const [t2, o3] of Object.entries(s2)) {
        const a2 = Number(t2);
        n2 += this.formatTokens(o3[0], i2), s2[a2 + 1] && (n2 += e2.substring(o3.index + o3[0].length, s2[a2 + 1].index)), a2 === s2.length - 1 && (n2 += e2.substring(o3.index + o3[0].length));
      }
    }
    return n2.replace(/\\/g, "");
  }
  midnight_ts(t2) {
    return t2 ? new Date(t2.getFullYear(), t2.getMonth(), t2.getDate(), 0, 0, 0, 0).getTime() : new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0, 0).getTime();
  }
  formatTokens(e2, i2) {
    switch (e2) {
      case "YY":
        return String(this.getFullYear()).slice(-2);
      case "YYYY":
        return String(this.getFullYear());
      case "M":
        return String(this.getMonth() + 1);
      case "MM":
        return `0${this.getMonth() + 1}`.slice(-2);
      case "MMM":
        return _t.shortMonths(i2)[this.getMonth()];
      case "MMMM":
        return _t.longMonths(i2)[this.getMonth()];
      case "D":
        return String(this.getDate());
      case "DD":
        return `0${this.getDate()}`.slice(-2);
      case "H":
        return String(this.getHours());
      case "HH":
        return `0${this.getHours()}`.slice(-2);
      case "h":
        return String(this.getHours() % 12 || 12);
      case "hh":
        return `0${this.getHours() % 12 || 12}`.slice(-2);
      case "m":
        return String(this.getMinutes());
      case "mm":
        return `0${this.getMinutes()}`.slice(-2);
      case "s":
        return String(this.getSeconds());
      case "ss":
        return `0${this.getSeconds()}`.slice(-2);
      case "a":
        return this.getHours() < 12 || 24 === this.getHours() ? "am" : "pm";
      case "A":
        return this.getHours() < 12 || 24 === this.getHours() ? "AM" : "PM";
      default:
        return "";
    }
  }
};
var t = _t;
__publicField(t, "regex", /(\\)?(Y{2,4}|M{1,4}|D{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|A|a)/g);
__publicField(t, "MONTH_JS", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
var e = class {
  constructor(t2) {
    __publicField(this, "picker");
    this.picker = t2;
  }
  render(e2, i2) {
    e2 || (e2 = new t()), e2.setDate(1), e2.setHours(0, 0, 0, 0), "function" == typeof this[`get${i2}View`] && this[`get${i2}View`](e2);
  }
  getContainerView(t2) {
    this.picker.ui.container.innerHTML = "", this.picker.options.header && this.picker.trigger("render", { date: t2.clone(), view: "Header" }), this.picker.trigger("render", { date: t2.clone(), view: "Main" }), this.picker.options.autoApply || this.picker.trigger("render", { date: t2.clone(), view: "Footer" });
  }
  getHeaderView(t2) {
    const e2 = document.createElement("header");
    this.picker.options.header instanceof HTMLElement && e2.appendChild(this.picker.options.header), "string" == typeof this.picker.options.header && (e2.innerHTML = this.picker.options.header), this.picker.ui.container.appendChild(e2), this.picker.trigger("view", { target: e2, date: t2.clone(), view: "Header" });
  }
  getMainView(t2) {
    const e2 = document.createElement("main");
    this.picker.ui.container.appendChild(e2);
    const i2 = document.createElement("div");
    i2.className = `calendars grid-${this.picker.options.grid}`;
    for (let e3 = 0; e3 < this.picker.options.calendars; e3++) {
      const n2 = document.createElement("div");
      n2.className = "calendar", i2.appendChild(n2);
      const s2 = this.getCalendarHeaderView(t2.clone());
      n2.appendChild(s2), this.picker.trigger("view", { date: t2.clone(), view: "CalendarHeader", index: e3, target: s2 });
      const o2 = this.getCalendarDayNamesView();
      n2.appendChild(o2), this.picker.trigger("view", { date: t2.clone(), view: "CalendarDayNames", index: e3, target: o2 });
      const a2 = this.getCalendarDaysView(t2.clone());
      n2.appendChild(a2), this.picker.trigger("view", { date: t2.clone(), view: "CalendarDays", index: e3, target: a2 });
      const r2 = this.getCalendarFooterView(this.picker.options.lang, t2.clone());
      n2.appendChild(r2), this.picker.trigger("view", { date: t2.clone(), view: "CalendarFooter", index: e3, target: r2 }), this.picker.trigger("view", { date: t2.clone(), view: "CalendarItem", index: e3, target: n2 }), t2.add(1, "month");
    }
    e2.appendChild(i2), this.picker.trigger("view", { date: t2.clone(), view: "Calendars", target: i2 }), this.picker.trigger("view", { date: t2.clone(), view: "Main", target: e2 });
  }
  getFooterView(t2) {
    const e2 = document.createElement("footer"), i2 = document.createElement("div");
    i2.className = "footer-buttons";
    const n2 = document.createElement("button");
    n2.className = "cancel-button unit", n2.innerHTML = this.picker.options.locale.cancel, i2.appendChild(n2);
    const s2 = document.createElement("button");
    s2.className = "apply-button unit", s2.innerHTML = this.picker.options.locale.apply, s2.disabled = true, i2.appendChild(s2), e2.appendChild(i2), this.picker.ui.container.appendChild(e2), this.picker.trigger("view", { date: t2, target: e2, view: "Footer" });
  }
  getCalendarHeaderView(t2) {
    const e2 = document.createElement("div");
    e2.className = "header";
    const i2 = document.createElement("div");
    i2.className = "month-name", i2.innerHTML = `<span>${t2.toLocaleString(this.picker.options.lang, { month: "long" })}</span> ${t2.format("YYYY")}`, e2.appendChild(i2);
    const n2 = document.createElement("button");
    n2.className = "previous-button unit", n2.innerHTML = this.picker.options.locale.previousMonth, e2.appendChild(n2);
    const s2 = document.createElement("button");
    return s2.className = "next-button unit", s2.innerHTML = this.picker.options.locale.nextMonth, e2.appendChild(s2), e2;
  }
  getCalendarDayNamesView() {
    const t2 = document.createElement("div");
    t2.className = "daynames-row";
    for (let e2 = 1; e2 <= 7; e2++) {
      const i2 = 3 + this.picker.options.firstDay + e2, n2 = document.createElement("div");
      n2.className = "dayname", n2.innerHTML = new Date(1970, 0, i2, 12, 0, 0, 0).toLocaleString(this.picker.options.lang, { weekday: "short" }), n2.title = new Date(1970, 0, i2, 12, 0, 0, 0).toLocaleString(this.picker.options.lang, { weekday: "long" }), t2.appendChild(n2), this.picker.trigger("view", { dayIdx: i2, view: "CalendarDayName", target: n2 });
    }
    return t2;
  }
  getCalendarDaysView(t2) {
    const e2 = document.createElement("div");
    e2.className = "days-grid";
    const i2 = this.calcOffsetDays(t2, this.picker.options.firstDay), n2 = 32 - new Date(t2.getFullYear(), t2.getMonth(), 32).getDate();
    for (let t3 = 0; t3 < i2; t3++) {
      const t4 = document.createElement("div");
      t4.className = "offset", e2.appendChild(t4);
    }
    for (let i3 = 1; i3 <= n2; i3++) {
      t2.setDate(i3);
      const n3 = this.getCalendarDayView(t2);
      e2.appendChild(n3), this.picker.trigger("view", { date: t2, view: "CalendarDay", target: n3 });
    }
    return e2;
  }
  getCalendarDayView(e2) {
    const i2 = this.picker.options.date ? new t(this.picker.options.date) : null, n2 = new t(), s2 = document.createElement("div");
    return s2.className = "day unit", s2.innerHTML = e2.format("D"), s2.dataset.time = String(e2.getTime()), e2.isSame(n2, "day") && s2.classList.add("today"), [0, 6].includes(e2.getDay()) && s2.classList.add("weekend"), this.picker.datePicked.length ? this.picker.datePicked[0].isSame(e2, "day") && s2.classList.add("selected") : i2 && e2.isSame(i2, "day") && s2.classList.add("selected"), this.picker.trigger("view", { date: e2, view: "CalendarDay", target: s2 }), s2;
  }
  getCalendarFooterView(t2, e2) {
    const i2 = document.createElement("div");
    return i2.className = "footer", i2;
  }
  calcOffsetDays(t2, e2) {
    let i2 = t2.getDay() - e2;
    return i2 < 0 && (i2 += 7), i2;
  }
};
var i = class {
  constructor(t2) {
    __publicField(this, "picker");
    __publicField(this, "instances", {});
    this.picker = t2;
  }
  initialize() {
    const t2 = [];
    this.picker.options.plugins.forEach((e2) => {
      "function" == typeof e2 ? t2.push(new e2()) : "string" == typeof e2 && "undefined" != typeof easepick && Object.prototype.hasOwnProperty.call(easepick, e2) ? t2.push(new easepick[e2]()) : console.warn(`easepick: ${e2} not found.`);
    }), t2.sort((t3, e2) => t3.priority > e2.priority ? -1 : t3.priority < e2.priority || t3.dependencies.length > e2.dependencies.length ? 1 : t3.dependencies.length < e2.dependencies.length ? -1 : 0), t2.forEach((t3) => {
      t3.attach(this.picker), this.instances[t3.getName()] = t3;
    });
  }
  getInstance(t2) {
    return this.instances[t2];
  }
  addInstance(t2) {
    if (Object.prototype.hasOwnProperty.call(this.instances, t2))
      console.warn(`easepick: ${t2} already added.`);
    else {
      if ("undefined" != typeof easepick && Object.prototype.hasOwnProperty.call(easepick, t2)) {
        const e2 = new easepick[t2]();
        return e2.attach(this.picker), this.instances[e2.getName()] = e2, e2;
      }
      if ("undefined" !== this.getPluginFn(t2)) {
        const e2 = new (this.getPluginFn(t2))();
        return e2.attach(this.picker), this.instances[e2.getName()] = e2, e2;
      }
      console.warn(`easepick: ${t2} not found.`);
    }
    return null;
  }
  removeInstance(t2) {
    return t2 in this.instances && this.instances[t2].detach(), delete this.instances[t2];
  }
  reloadInstance(t2) {
    return this.removeInstance(t2), this.addInstance(t2);
  }
  getPluginFn(t2) {
    return [...this.picker.options.plugins].filter((e2) => "function" == typeof e2 && new e2().getName() === t2).shift();
  }
};
var n = class {
  constructor(t2) {
    __publicField(this, "Calendar", new e(this));
    __publicField(this, "PluginManager", new i(this));
    __publicField(this, "calendars", []);
    __publicField(this, "datePicked", []);
    __publicField(this, "cssLoaded", 0);
    __publicField(this, "binds", { hidePicker: this.hidePicker.bind(this), show: this.show.bind(this) });
    __publicField(this, "options", { doc: document, css: [], element: null, firstDay: 1, grid: 1, calendars: 1, lang: "en-US", date: null, format: "YYYY-MM-DD", readonly: true, autoApply: true, header: false, inline: false, scrollToDate: true, locale: { nextMonth: '<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M2.748 16L0 13.333 5.333 8 0 2.667 2.748 0l7.919 8z" fill-rule="nonzero"/></svg>', previousMonth: '<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M7.919 0l2.748 2.667L5.333 8l5.334 5.333L7.919 16 0 8z" fill-rule="nonzero"/></svg>', cancel: "Cancel", apply: "Apply" }, documentClick: this.binds.hidePicker, plugins: [] });
    __publicField(this, "ui", { container: null, shadowRoot: null, wrapper: null });
    __publicField(this, "version", "1.2.0");
    const e2 = { ...this.options.locale, ...t2.locale };
    this.options = { ...this.options, ...t2 }, this.options.locale = e2, this.handleOptions(), this.ui.wrapper = document.createElement("span"), this.ui.wrapper.style.display = "none", this.ui.wrapper.style.position = "absolute", this.ui.wrapper.style.pointerEvents = "none", this.ui.wrapper.className = "easepick-wrapper", this.ui.wrapper.attachShadow({ mode: "open" }), this.ui.shadowRoot = this.ui.wrapper.shadowRoot, this.ui.container = document.createElement("div"), this.ui.container.className = "container", this.options.zIndex && (this.ui.container.style.zIndex = String(this.options.zIndex)), this.options.inline && (this.ui.wrapper.style.position = "relative", this.ui.container.classList.add("inline")), this.ui.shadowRoot.appendChild(this.ui.container), this.options.element.after(this.ui.wrapper), this.handleCSS(), this.options.element.addEventListener("click", this.binds.show), this.on("view", this.onView.bind(this)), this.on("render", this.onRender.bind(this)), this.PluginManager.initialize(), this.parseValues(), "function" == typeof this.options.setup && this.options.setup(this), this.on("click", this.onClick.bind(this));
    const i2 = this.options.scrollToDate ? this.getDate() : null;
    this.renderAll(i2);
  }
  on(t2, e2, i2 = {}) {
    this.ui.container.addEventListener(t2, e2, i2);
  }
  off(t2, e2, i2 = {}) {
    this.ui.container.removeEventListener(t2, e2, i2);
  }
  trigger(t2, e2 = {}) {
    return this.ui.container.dispatchEvent(new CustomEvent(t2, { detail: e2 }));
  }
  destroy() {
    this.options.element.removeEventListener("click", this.binds.show), "function" == typeof this.options.documentClick && document.removeEventListener("click", this.options.documentClick, true), Object.keys(this.PluginManager.instances).forEach((t2) => {
      this.PluginManager.removeInstance(t2);
    }), this.ui.wrapper.remove();
  }
  onRender(t2) {
    const { view: e2, date: i2 } = t2.detail;
    this.Calendar.render(i2, e2);
  }
  onView(t2) {
    const { view: e2, target: i2 } = t2.detail;
    "Footer" === e2 && this.datePicked.length && (i2.querySelector(".apply-button").disabled = false);
  }
  onClickHeaderButton(t2) {
    this.isCalendarHeaderButton(t2) && (t2.classList.contains("next-button") ? this.calendars[0].add(1, "month") : this.calendars[0].subtract(1, "month"), this.renderAll(this.calendars[0]));
  }
  onClickCalendarDay(e2) {
    if (this.isCalendarDay(e2)) {
      const i2 = new t(e2.dataset.time);
      this.options.autoApply ? (this.setDate(i2), this.trigger("select", { date: this.getDate() }), this.hide()) : (this.datePicked[0] = i2, this.trigger("preselect", { date: this.getDate() }), this.renderAll());
    }
  }
  onClickApplyButton(t2) {
    if (this.isApplyButton(t2)) {
      if (this.datePicked[0] instanceof Date) {
        const t3 = this.datePicked[0].clone();
        this.setDate(t3);
      }
      this.hide(), this.trigger("select", { date: this.getDate() });
    }
  }
  onClickCancelButton(t2) {
    this.isCancelButton(t2) && this.hide();
  }
  onClick(t2) {
    const e2 = t2.target;
    if (e2 instanceof HTMLElement) {
      const t3 = e2.closest(".unit");
      if (!(t3 instanceof HTMLElement))
        return;
      this.onClickHeaderButton(t3), this.onClickCalendarDay(t3), this.onClickApplyButton(t3), this.onClickCancelButton(t3);
    }
  }
  isShown() {
    return this.ui.container.classList.contains("inline") || this.ui.container.classList.contains("show");
  }
  show(t2) {
    if (this.isShown())
      return;
    const e2 = t2 && "target" in t2 ? t2.target : this.options.element, { top: i2, left: n2 } = this.adjustPosition(e2);
    this.ui.container.style.top = `${i2}px`, this.ui.container.style.left = `${n2}px`, this.ui.container.classList.add("show"), this.trigger("show", { target: e2 });
  }
  hide() {
    this.ui.container.classList.remove("show"), this.datePicked.length = 0, this.renderAll(), this.trigger("hide");
  }
  setDate(e2) {
    const i2 = new t(e2, this.options.format);
    this.options.date = i2.clone(), this.updateValues(), this.calendars.length && this.renderAll();
  }
  getDate() {
    return this.options.date instanceof t ? this.options.date.clone() : null;
  }
  parseValues() {
    this.options.date ? this.setDate(this.options.date) : this.options.element instanceof HTMLInputElement && this.options.element.value.length && this.setDate(this.options.element.value), this.options.date instanceof Date || (this.options.date = null);
  }
  updateValues() {
    const t2 = this.getDate(), e2 = t2 instanceof Date ? t2.format(this.options.format, this.options.lang) : "", i2 = this.options.element;
    i2 instanceof HTMLInputElement ? i2.value = e2 : i2 instanceof HTMLElement && (i2.innerText = e2);
  }
  hidePicker(t2) {
    let e2 = t2.target, i2 = null;
    e2.shadowRoot && (e2 = t2.composedPath()[0], i2 = e2.getRootNode().host), this.isShown() && i2 !== this.ui.wrapper && e2 !== this.options.element && this.hide();
  }
  renderAll(t2) {
    this.trigger("render", { view: "Container", date: (t2 || this.calendars[0]).clone() });
  }
  isCalendarHeaderButton(t2) {
    return ["previous-button", "next-button"].some((e2) => t2.classList.contains(e2));
  }
  isCalendarDay(t2) {
    return t2.classList.contains("day");
  }
  isApplyButton(t2) {
    return t2.classList.contains("apply-button");
  }
  isCancelButton(t2) {
    return t2.classList.contains("cancel-button");
  }
  gotoDate(e2) {
    const i2 = new t(e2, this.options.format);
    i2.setDate(1), this.calendars[0] = i2.clone(), this.renderAll();
  }
  clear() {
    this.options.date = null, this.datePicked.length = 0, this.updateValues(), this.renderAll(), this.trigger("clear");
  }
  handleOptions() {
    this.options.element instanceof HTMLElement || (this.options.element = this.options.doc.querySelector(this.options.element)), "function" == typeof this.options.documentClick && document.addEventListener("click", this.options.documentClick, true), this.options.element instanceof HTMLInputElement && (this.options.element.readOnly = this.options.readonly), this.options.date ? this.calendars[0] = new t(this.options.date, this.options.format) : this.calendars[0] = new t();
  }
  handleCSS() {
    if (Array.isArray(this.options.css))
      this.options.css.forEach((t2) => {
        const e2 = document.createElement("link");
        e2.href = t2, e2.rel = "stylesheet";
        const i2 = () => {
          this.cssLoaded++, this.cssLoaded === this.options.css.length && (this.ui.wrapper.style.display = "");
        };
        e2.addEventListener("load", i2), e2.addEventListener("error", i2), this.ui.shadowRoot.append(e2);
      });
    else if ("string" == typeof this.options.css) {
      const t2 = document.createElement("style"), e2 = document.createTextNode(this.options.css);
      t2.appendChild(e2), this.ui.shadowRoot.append(t2), this.ui.wrapper.style.display = "";
    } else
      "function" == typeof this.options.css && (this.options.css.call(this, this), this.ui.wrapper.style.display = "");
  }
  adjustPosition(t2) {
    const e2 = t2.getBoundingClientRect(), i2 = this.ui.wrapper.getBoundingClientRect();
    this.ui.container.classList.add("calc");
    const n2 = this.ui.container.getBoundingClientRect();
    this.ui.container.classList.remove("calc");
    let s2 = e2.bottom - i2.bottom, o2 = e2.left - i2.left;
    return "undefined" != typeof window && (window.innerHeight < s2 + n2.height && s2 - n2.height >= 0 && (s2 = e2.top - i2.top - n2.height), window.innerWidth < o2 + n2.width && e2.right - n2.width >= 0 && (o2 = e2.right - i2.right - n2.width)), { left: o2, top: s2 };
  }
};
var s = Object.freeze({ __proto__: null, Core: n, create: n });
var o = class {
  constructor() {
    __publicField(this, "picker");
    __publicField(this, "options");
    __publicField(this, "priority", 0);
    __publicField(this, "dependencies", []);
  }
  attach(t2) {
    const e2 = this.getName(), i2 = { ...this.options };
    this.options = { ...this.options, ...t2.options[e2] || {} };
    for (const n3 of Object.keys(i2))
      if (null !== i2[n3] && "object" == typeof i2[n3] && Object.keys(i2[n3]).length && e2 in t2.options && n3 in t2.options[e2]) {
        const s2 = { ...t2.options[e2][n3] };
        null !== s2 && "object" == typeof s2 && Object.keys(s2).length && Object.keys(s2).every((t3) => Object.keys(i2[n3]).includes(t3)) && (this.options[n3] = { ...i2[n3], ...s2 });
      }
    if (this.picker = t2, this.dependenciesNotFound()) {
      const t3 = this.dependencies.filter((t4) => !this.pluginsAsStringArray().includes(t4));
      return void console.warn(`${this.getName()}: required dependencies (${t3.join(", ")}).`);
    }
    const n2 = this.camelCaseToKebab(this.getName());
    this.picker.ui.container.classList.add(n2), this.onAttach();
  }
  detach() {
    const t2 = this.camelCaseToKebab(this.getName());
    this.picker.ui.container.classList.remove(t2), "function" == typeof this.onDetach && this.onDetach();
  }
  dependenciesNotFound() {
    return this.dependencies.length && !this.dependencies.every((t2) => this.pluginsAsStringArray().includes(t2));
  }
  pluginsAsStringArray() {
    return this.picker.options.plugins.map((t2) => "function" == typeof t2 ? new t2().getName() : t2);
  }
  camelCaseToKebab(t2) {
    return t2.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();
  }
};
var a = class extends o {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 1);
    __publicField(this, "binds", { onView: this.onView.bind(this) });
    __publicField(this, "options", { minDate: null, maxDate: null, minDays: null, maxDays: null, selectForward: null, selectBackward: null, presets: true, inseparable: false, filter: null });
  }
  getName() {
    return "LockPlugin";
  }
  onAttach() {
    if (this.options.minDate && (this.options.minDate = new t(this.options.minDate, this.picker.options.format, this.picker.options.lang)), this.options.maxDate && (this.options.maxDate = new t(this.options.maxDate, this.picker.options.format, this.picker.options.lang), this.options.maxDate instanceof t && this.picker.options.calendars > 1 && this.picker.calendars[0].isSame(this.options.maxDate, "month"))) {
      const t2 = this.picker.calendars[0].clone().subtract(1, "month");
      this.picker.gotoDate(t2);
    }
    if ((this.options.minDays || this.options.maxDays || this.options.selectForward || this.options.selectBackward) && !this.picker.options.plugins.includes("RangePlugin")) {
      const t2 = ["minDays", "maxDays", "selectForward", "selectBackward"];
      console.warn(`${this.getName()}: options ${t2.join(", ")} required RangePlugin.`);
    }
    this.picker.on("view", this.binds.onView);
  }
  onDetach() {
    this.picker.off("view", this.binds.onView);
  }
  onView(e2) {
    const { view: i2, target: n2, date: s2 } = e2.detail;
    if ("CalendarHeader" === i2 && (this.options.minDate instanceof t && s2.isSameOrBefore(this.options.minDate, "month") && n2.classList.add("no-previous-month"), this.options.maxDate instanceof t && s2.isSameOrAfter(this.options.maxDate, "month") && n2.classList.add("no-next-month")), "CalendarDay" === i2) {
      const t2 = this.picker.datePicked.length ? this.picker.datePicked[0] : null;
      if (this.testFilter(s2))
        return void n2.classList.add("locked");
      if (this.options.inseparable) {
        if (this.options.minDays) {
          const t3 = s2.clone().subtract(this.options.minDays - 1, "day"), e3 = s2.clone().add(this.options.minDays - 1, "day");
          let i3 = false, o2 = false;
          for (; t3.isBefore(s2, "day"); ) {
            if (this.testFilter(t3)) {
              i3 = true;
              break;
            }
            t3.add(1, "day");
          }
          for (; e3.isAfter(s2, "day"); ) {
            if (this.testFilter(e3)) {
              o2 = true;
              break;
            }
            e3.subtract(1, "day");
          }
          i3 && o2 && n2.classList.add("not-available");
        }
        this.rangeIsNotAvailable(s2, t2) && n2.classList.add("not-available");
      }
      this.dateIsNotAvailable(s2, t2) && n2.classList.add("not-available");
    }
    if (this.options.presets && "PresetPluginButton" === i2) {
      const e3 = new t(Number(n2.dataset.start)), i3 = new t(Number(n2.dataset.end)), s3 = i3.diff(e3, "day"), o2 = this.options.minDays && s3 < this.options.minDays, a2 = this.options.maxDays && s3 > this.options.maxDays;
      (o2 || a2 || this.lockMinDate(e3) || this.lockMaxDate(e3) || this.lockMinDate(i3) || this.lockMaxDate(i3) || this.rangeIsNotAvailable(e3, i3)) && n2.setAttribute("disabled", "disabled");
    }
  }
  dateIsNotAvailable(t2, e2) {
    return this.lockMinDate(t2) || this.lockMaxDate(t2) || this.lockMinDays(t2, e2) || this.lockMaxDays(t2, e2) || this.lockSelectForward(t2) || this.lockSelectBackward(t2);
  }
  rangeIsNotAvailable(t2, e2) {
    if (!t2 || !e2)
      return false;
    const i2 = (t2.isSameOrBefore(e2, "day") ? t2 : e2).clone(), n2 = (e2.isSameOrAfter(t2, "day") ? e2 : t2).clone();
    for (; i2.isSameOrBefore(n2, "day"); ) {
      if (this.testFilter(i2))
        return true;
      i2.add(1, "day");
    }
    return false;
  }
  lockMinDate(e2) {
    return this.options.minDate instanceof t && e2.isBefore(this.options.minDate, "day");
  }
  lockMaxDate(e2) {
    return this.options.maxDate instanceof t && e2.isAfter(this.options.maxDate, "day");
  }
  lockMinDays(t2, e2) {
    if (this.options.minDays && e2) {
      const i2 = e2.clone().subtract(this.options.minDays - 1, "day"), n2 = e2.clone().add(this.options.minDays - 1, "day");
      return t2.isBetween(i2, n2);
    }
    return false;
  }
  lockMaxDays(t2, e2) {
    if (this.options.maxDays && e2) {
      const i2 = e2.clone().subtract(this.options.maxDays, "day"), n2 = e2.clone().add(this.options.maxDays, "day");
      return !t2.isBetween(i2, n2);
    }
    return false;
  }
  lockSelectForward(t2) {
    if (1 === this.picker.datePicked.length && this.options.selectForward) {
      const e2 = this.picker.datePicked[0].clone();
      return t2.isBefore(e2, "day");
    }
    return false;
  }
  lockSelectBackward(t2) {
    if (1 === this.picker.datePicked.length && this.options.selectBackward) {
      const e2 = this.picker.datePicked[0].clone();
      return t2.isAfter(e2, "day");
    }
    return false;
  }
  testFilter(t2) {
    return "function" == typeof this.options.filter && this.options.filter(t2, this.picker.datePicked);
  }
};
var r = class extends o {
  constructor() {
    super(...arguments);
    __publicField(this, "dependencies", ["RangePlugin"]);
    __publicField(this, "binds", { onView: this.onView.bind(this), onClick: this.onClick.bind(this) });
    __publicField(this, "options", { customLabels: ["Today", "Yesterday", "Last 7 Days", "Last 30 Days", "This Month", "Last Month"], customPreset: {}, position: "left" });
  }
  getName() {
    return "PresetPlugin";
  }
  onAttach() {
    if (!Object.keys(this.options.customPreset).length) {
      const e2 = new t(), i2 = () => {
        const i3 = e2.clone();
        i3.setDate(1);
        const n3 = new Date(e2.getFullYear(), e2.getMonth() + 1, 0);
        return [new t(i3), new t(n3)];
      }, n2 = () => {
        const i3 = e2.clone();
        i3.setMonth(i3.getMonth() - 1), i3.setDate(1);
        const n3 = new Date(e2.getFullYear(), e2.getMonth(), 0);
        return [new t(i3), new t(n3)];
      }, s2 = [[e2.clone(), e2.clone()], [e2.clone().subtract(1, "day"), e2.clone().subtract(1, "day")], [e2.clone().subtract(6, "day"), e2.clone()], [e2.clone().subtract(29, "day"), e2.clone()], i2(), n2()];
      Object.values(this.options.customLabels).forEach((t2, e3) => {
        this.options.customPreset[t2] = s2[e3];
      });
    }
    this.picker.on("view", this.binds.onView), this.picker.on("click", this.binds.onClick);
  }
  onDetach() {
    this.picker.off("view", this.binds.onView), this.picker.off("click", this.binds.onClick);
  }
  onView(t2) {
    const { view: e2, target: i2 } = t2.detail;
    if ("Main" === e2) {
      const t3 = document.createElement("div");
      t3.className = "preset-plugin-container", Object.keys(this.options.customPreset).forEach((e3) => {
        if (Object.prototype.hasOwnProperty.call(this.options.customPreset, e3)) {
          const i3 = this.options.customPreset[e3], n2 = document.createElement("button");
          n2.className = "preset-button unit", n2.innerHTML = e3, n2.dataset.start = i3[0].getTime(), n2.dataset.end = i3[1].getTime(), t3.appendChild(n2), this.picker.trigger("view", { view: "PresetPluginButton", target: n2 });
        }
      }), i2.appendChild(t3), i2.classList.add(`preset-${this.options.position}`), this.picker.trigger("view", { view: "PresetPluginContainer", target: t3 });
    }
  }
  onClick(e2) {
    const i2 = e2.target;
    if (i2 instanceof HTMLElement) {
      const e3 = i2.closest(".unit");
      if (!(e3 instanceof HTMLElement))
        return;
      if (this.isPresetButton(e3)) {
        const i3 = new t(Number(e3.dataset.start)), n2 = new t(Number(e3.dataset.end));
        this.picker.options.autoApply ? (this.picker.setDateRange(i3, n2), this.picker.trigger("select", { start: this.picker.getStartDate(), end: this.picker.getEndDate() }), this.picker.hide()) : (this.picker.datePicked = [i3, n2], this.picker.renderAll());
      }
    }
  }
  isPresetButton(t2) {
    return t2.classList.contains("preset-button");
  }
};
var c = class extends o {
  constructor() {
    super(...arguments);
    __publicField(this, "tooltipElement");
    __publicField(this, "triggerElement");
    __publicField(this, "binds", { setStartDate: this.setStartDate.bind(this), setEndDate: this.setEndDate.bind(this), setDateRange: this.setDateRange.bind(this), getStartDate: this.getStartDate.bind(this), getEndDate: this.getEndDate.bind(this), onView: this.onView.bind(this), onShow: this.onShow.bind(this), onMouseEnter: this.onMouseEnter.bind(this), onMouseLeave: this.onMouseLeave.bind(this), onClickCalendarDay: this.onClickCalendarDay.bind(this), onClickApplyButton: this.onClickApplyButton.bind(this), parseValues: this.parseValues.bind(this), updateValues: this.updateValues.bind(this), clear: this.clear.bind(this) });
    __publicField(this, "options", { elementEnd: null, startDate: null, endDate: null, repick: false, strict: true, delimiter: " - ", tooltip: true, tooltipNumber: (t2) => t2, locale: { zero: "", one: "day", two: "", few: "", many: "", other: "days" }, documentClick: this.hidePicker.bind(this) });
  }
  getName() {
    return "RangePlugin";
  }
  onAttach() {
    this.binds._setStartDate = this.picker.setStartDate, this.binds._setEndDate = this.picker.setEndDate, this.binds._setDateRange = this.picker.setDateRange, this.binds._getStartDate = this.picker.getStartDate, this.binds._getEndDate = this.picker.getEndDate, this.binds._parseValues = this.picker.parseValues, this.binds._updateValues = this.picker.updateValues, this.binds._clear = this.picker.clear, this.binds._onClickCalendarDay = this.picker.onClickCalendarDay, this.binds._onClickApplyButton = this.picker.onClickApplyButton, Object.defineProperties(this.picker, { setStartDate: { configurable: true, value: this.binds.setStartDate }, setEndDate: { configurable: true, value: this.binds.setEndDate }, setDateRange: { configurable: true, value: this.binds.setDateRange }, getStartDate: { configurable: true, value: this.binds.getStartDate }, getEndDate: { configurable: true, value: this.binds.getEndDate }, parseValues: { configurable: true, value: this.binds.parseValues }, updateValues: { configurable: true, value: this.binds.updateValues }, clear: { configurable: true, value: this.binds.clear }, onClickCalendarDay: { configurable: true, value: this.binds.onClickCalendarDay }, onClickApplyButton: { configurable: true, value: this.binds.onClickApplyButton } }), this.options.elementEnd && (this.options.elementEnd instanceof HTMLElement || (this.options.elementEnd = this.picker.options.doc.querySelector(this.options.elementEnd)), this.options.elementEnd instanceof HTMLInputElement && (this.options.elementEnd.readOnly = this.picker.options.readonly), "function" == typeof this.picker.options.documentClick && (document.removeEventListener("click", this.picker.options.documentClick, true), "function" == typeof this.options.documentClick && document.addEventListener("click", this.options.documentClick, true)), this.options.elementEnd.addEventListener("click", this.picker.show.bind(this.picker))), this.options.repick = this.options.repick && this.options.elementEnd instanceof HTMLElement, this.picker.options.date = null, this.picker.on("view", this.binds.onView), this.picker.on("show", this.binds.onShow), this.picker.on("mouseenter", this.binds.onMouseEnter, true), this.picker.on("mouseleave", this.binds.onMouseLeave, true), this.checkIntlPluralLocales();
  }
  onDetach() {
    Object.defineProperties(this.picker, { setStartDate: { configurable: true, value: this.binds._setStartDate }, setEndDate: { configurable: true, value: this.binds._setEndDate }, setDateRange: { configurable: true, value: this.binds._setDateRange }, getStartDate: { configurable: true, value: this.binds._getStartDate }, getEndDate: { configurable: true, value: this.binds._getEndDate }, parseValues: { configurable: true, value: this.binds._parseValues }, updateValues: { configurable: true, value: this.binds._updateValues }, clear: { configurable: true, value: this.binds._clear }, onClickCalendarDay: { configurable: true, value: this.binds._onClickCalendarDay }, onClickApplyButton: { configurable: true, value: this.binds._onClickApplyButton } }), this.picker.off("view", this.binds.onView), this.picker.off("show", this.binds.onShow), this.picker.off("mouseenter", this.binds.onMouseEnter, true), this.picker.off("mouseleave", this.binds.onMouseLeave, true);
  }
  parseValues() {
    if (this.options.startDate || this.options.endDate)
      this.options.strict ? this.options.startDate && this.options.endDate ? this.setDateRange(this.options.startDate, this.options.endDate) : (this.options.startDate = null, this.options.endDate = null) : (this.options.startDate && this.setStartDate(this.options.startDate), this.options.endDate && this.setEndDate(this.options.endDate));
    else if (this.options.elementEnd)
      this.options.strict ? this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length && this.options.elementEnd instanceof HTMLInputElement && this.options.elementEnd.value.length && this.setDateRange(this.picker.options.element.value, this.options.elementEnd.value) : (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length && this.setStartDate(this.picker.options.element.value), this.options.elementEnd instanceof HTMLInputElement && this.options.elementEnd.value.length && this.setEndDate(this.options.elementEnd.value));
    else if (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length) {
      const [t2, e2] = this.picker.options.element.value.split(this.options.delimiter);
      this.options.strict ? t2 && e2 && this.setDateRange(t2, e2) : (t2 && this.setStartDate(t2), e2 && this.setEndDate(e2));
    }
  }
  updateValues() {
    const t2 = this.picker.options.element, e2 = this.options.elementEnd, i2 = this.picker.getStartDate(), n2 = this.picker.getEndDate(), s2 = i2 instanceof Date ? i2.format(this.picker.options.format, this.picker.options.lang) : "", o2 = n2 instanceof Date ? n2.format(this.picker.options.format, this.picker.options.lang) : "";
    if (e2)
      t2 instanceof HTMLInputElement ? t2.value = s2 : t2 instanceof HTMLElement && (t2.innerText = s2), e2 instanceof HTMLInputElement ? e2.value = o2 : e2 instanceof HTMLElement && (e2.innerText = o2);
    else {
      const e3 = `${s2}${s2 || o2 ? this.options.delimiter : ""}${o2}`;
      t2 instanceof HTMLInputElement ? t2.value = e3 : t2 instanceof HTMLElement && (t2.innerText = e3);
    }
  }
  clear() {
    this.options.startDate = null, this.options.endDate = null, this.picker.datePicked.length = 0, this.updateValues(), this.picker.renderAll(), this.picker.trigger("clear");
  }
  onShow(t2) {
    const { target: e2 } = t2.detail;
    this.triggerElement = e2, this.picker.options.scrollToDate && this.getStartDate() instanceof Date && this.picker.gotoDate(this.getStartDate()), this.initializeRepick();
  }
  onView(e2) {
    const { view: i2, target: n2 } = e2.detail;
    if ("Main" === i2 && (this.tooltipElement = document.createElement("span"), this.tooltipElement.className = "range-plugin-tooltip", n2.appendChild(this.tooltipElement)), "CalendarDay" === i2) {
      const e3 = new t(n2.dataset.time), i3 = this.picker.datePicked, s2 = i3.length ? this.picker.datePicked[0] : this.getStartDate(), o2 = i3.length ? this.picker.datePicked[1] : this.getEndDate();
      s2 && s2.isSame(e3, "day") && n2.classList.add("start"), s2 && o2 && (o2.isSame(e3, "day") && n2.classList.add("end"), e3.isBetween(s2, o2) && n2.classList.add("in-range"));
    }
    if ("Footer" === i2) {
      const t2 = 1 === this.picker.datePicked.length && !this.options.strict || 2 === this.picker.datePicked.length;
      n2.querySelector(".apply-button").disabled = !t2;
    }
  }
  hidePicker(t2) {
    let e2 = t2.target, i2 = null;
    e2.shadowRoot && (e2 = t2.composedPath()[0], i2 = e2.getRootNode().host), this.picker.isShown() && i2 !== this.picker.ui.wrapper && e2 !== this.picker.options.element && e2 !== this.options.elementEnd && this.picker.hide();
  }
  setStartDate(e2) {
    const i2 = new t(e2, this.picker.options.format);
    this.options.startDate = i2 ? i2.clone() : null, this.updateValues(), this.picker.renderAll();
  }
  setEndDate(e2) {
    const i2 = new t(e2, this.picker.options.format);
    this.options.endDate = i2 ? i2.clone() : null, this.updateValues(), this.picker.renderAll();
  }
  setDateRange(e2, i2) {
    const n2 = new t(e2, this.picker.options.format), s2 = new t(i2, this.picker.options.format);
    this.options.startDate = n2 ? n2.clone() : null, this.options.endDate = s2 ? s2.clone() : null, this.updateValues(), this.picker.renderAll();
  }
  getStartDate() {
    return this.options.startDate instanceof Date ? this.options.startDate.clone() : null;
  }
  getEndDate() {
    return this.options.endDate instanceof Date ? this.options.endDate.clone() : null;
  }
  onMouseEnter(e2) {
    const i2 = e2.target;
    if (i2 instanceof HTMLElement) {
      this.isContainer(i2) && this.initializeRepick();
      const e3 = i2.closest(".unit");
      if (!(e3 instanceof HTMLElement))
        return;
      if (this.picker.isCalendarDay(e3)) {
        if (1 !== this.picker.datePicked.length)
          return;
        let i3 = this.picker.datePicked[0].clone(), n2 = new t(e3.dataset.time), s2 = false;
        if (i3.isAfter(n2, "day")) {
          const t2 = i3.clone();
          i3 = n2.clone(), n2 = t2.clone(), s2 = true;
        }
        if ([...this.picker.ui.container.querySelectorAll(".day")].forEach((o2) => {
          const a2 = new t(o2.dataset.time), r2 = this.picker.Calendar.getCalendarDayView(a2);
          a2.isBetween(i3, n2) && r2.classList.add("in-range"), a2.isSame(this.picker.datePicked[0], "day") && (r2.classList.add("start"), r2.classList.toggle("flipped", s2)), o2 === e3 && (r2.classList.add("end"), r2.classList.toggle("flipped", s2)), o2.className = r2.className;
        }), this.options.tooltip) {
          const t2 = this.options.tooltipNumber(n2.diff(i3, "day") + 1);
          if (t2 > 0) {
            const i4 = new Intl.PluralRules(this.picker.options.lang).select(t2), n3 = `${t2} ${this.options.locale[i4]}`;
            this.showTooltip(e3, n3);
          } else
            this.hideTooltip();
        }
      }
    }
  }
  onMouseLeave(t2) {
    if (this.isContainer(t2.target) && this.options.repick) {
      const t3 = this.getStartDate(), e2 = this.getEndDate();
      t3 && e2 && (this.picker.datePicked.length = 0, this.picker.renderAll());
    }
  }
  onClickCalendarDay(e2) {
    if (this.picker.isCalendarDay(e2)) {
      2 === this.picker.datePicked.length && (this.picker.datePicked.length = 0);
      const i2 = new t(e2.dataset.time);
      if (this.picker.datePicked[this.picker.datePicked.length] = i2, 2 === this.picker.datePicked.length && this.picker.datePicked[0].isAfter(this.picker.datePicked[1])) {
        const t2 = this.picker.datePicked[1].clone();
        this.picker.datePicked[1] = this.picker.datePicked[0].clone(), this.picker.datePicked[0] = t2.clone();
      }
      1 !== this.picker.datePicked.length && this.picker.options.autoApply || this.picker.trigger("preselect", { start: this.picker.datePicked[0] instanceof Date ? this.picker.datePicked[0].clone() : null, end: this.picker.datePicked[1] instanceof Date ? this.picker.datePicked[1].clone() : null }), 1 === this.picker.datePicked.length && (!this.options.strict && this.picker.options.autoApply && (this.picker.options.element === this.triggerElement && this.setStartDate(this.picker.datePicked[0]), this.options.elementEnd === this.triggerElement && this.setEndDate(this.picker.datePicked[0]), this.picker.trigger("select", { start: this.picker.getStartDate(), end: this.picker.getEndDate() })), this.picker.renderAll()), 2 === this.picker.datePicked.length && (this.picker.options.autoApply ? (this.setDateRange(this.picker.datePicked[0], this.picker.datePicked[1]), this.picker.trigger("select", { start: this.picker.getStartDate(), end: this.picker.getEndDate() }), this.picker.hide()) : (this.hideTooltip(), this.picker.renderAll()));
    }
  }
  onClickApplyButton(t2) {
    this.picker.isApplyButton(t2) && (1 !== this.picker.datePicked.length || this.options.strict || (this.picker.options.element === this.triggerElement && (this.options.endDate = null, this.setStartDate(this.picker.datePicked[0])), this.options.elementEnd === this.triggerElement && (this.options.startDate = null, this.setEndDate(this.picker.datePicked[0]))), 2 === this.picker.datePicked.length && this.setDateRange(this.picker.datePicked[0], this.picker.datePicked[1]), this.picker.trigger("select", { start: this.picker.getStartDate(), end: this.picker.getEndDate() }), this.picker.hide());
  }
  showTooltip(t2, e2) {
    this.tooltipElement.style.visibility = "visible", this.tooltipElement.innerHTML = e2;
    const i2 = this.picker.ui.container.getBoundingClientRect(), n2 = this.tooltipElement.getBoundingClientRect(), s2 = t2.getBoundingClientRect();
    let o2 = s2.top, a2 = s2.left;
    o2 -= i2.top, a2 -= i2.left, o2 -= n2.height, a2 -= n2.width / 2, a2 += s2.width / 2, this.tooltipElement.style.top = `${o2}px`, this.tooltipElement.style.left = `${a2}px`;
  }
  hideTooltip() {
    this.tooltipElement.style.visibility = "hidden";
  }
  checkIntlPluralLocales() {
    if (!this.options.tooltip)
      return;
    const t2 = [.../* @__PURE__ */ new Set([new Intl.PluralRules(this.picker.options.lang).select(0), new Intl.PluralRules(this.picker.options.lang).select(1), new Intl.PluralRules(this.picker.options.lang).select(2), new Intl.PluralRules(this.picker.options.lang).select(6), new Intl.PluralRules(this.picker.options.lang).select(18)])], e2 = Object.keys(this.options.locale);
    t2.every((t3) => e2.includes(t3)) || console.warn(`${this.getName()}: provide locales (${t2.join(", ")}) for correct tooltip text.`);
  }
  initializeRepick() {
    if (!this.options.repick)
      return;
    const t2 = this.getStartDate(), e2 = this.getEndDate();
    e2 && this.triggerElement === this.picker.options.element && (this.picker.datePicked[0] = e2), t2 && this.triggerElement === this.options.elementEnd && (this.picker.datePicked[0] = t2);
  }
  isContainer(t2) {
    return t2 === this.picker.ui.container;
  }
};
var l = class extends o {
  constructor() {
    super(...arguments);
    __publicField(this, "options", { native: false, seconds: false, stepHours: 1, stepMinutes: 5, stepSeconds: 5, format12: false });
    __publicField(this, "rangePlugin");
    __publicField(this, "timePicked", { input: null, start: null, end: null });
    __publicField(this, "timePrePicked", { input: null, start: null, end: null });
    __publicField(this, "binds", { getDate: this.getDate.bind(this), getStartDate: this.getStartDate.bind(this), getEndDate: this.getEndDate.bind(this), onView: this.onView.bind(this), onInput: this.onInput.bind(this), onChange: this.onChange.bind(this), onClick: this.onClick.bind(this), setTime: this.setTime.bind(this), setStartTime: this.setStartTime.bind(this), setEndTime: this.setEndTime.bind(this) });
  }
  getName() {
    return "TimePlugin";
  }
  onAttach() {
    this.binds._getDate = this.picker.getDate, this.binds._getStartDate = this.picker.getStartDate, this.binds._getEndDate = this.picker.getEndDate, Object.defineProperties(this.picker, { getDate: { configurable: true, value: this.binds.getDate }, getStartDate: { configurable: true, value: this.binds.getStartDate }, getEndDate: { configurable: true, value: this.binds.getEndDate }, setTime: { configurable: true, value: this.binds.setTime }, setStartTime: { configurable: true, value: this.binds.setStartTime }, setEndTime: { configurable: true, value: this.binds.setEndTime } }), this.rangePlugin = this.picker.PluginManager.getInstance("RangePlugin"), this.parseValues(), this.picker.on("view", this.binds.onView), this.picker.on("input", this.binds.onInput), this.picker.on("change", this.binds.onChange), this.picker.on("click", this.binds.onClick);
  }
  onDetach() {
    delete this.picker.setTime, delete this.picker.setStartTime, delete this.picker.setEndTime, Object.defineProperties(this.picker, { getDate: { configurable: true, value: this.binds._getDate }, getStartDate: { configurable: true, value: this.binds._getStartDate }, getEndDate: { configurable: true, value: this.binds._getEndDate } }), this.picker.off("view", this.binds.onView), this.picker.off("input", this.binds.onInput), this.picker.off("change", this.binds.onChange), this.picker.off("click", this.binds.onClick);
  }
  onView(t2) {
    const { view: e2, target: i2 } = t2.detail;
    if ("Main" === e2) {
      this.rangePlugin = this.picker.PluginManager.getInstance("RangePlugin");
      const t3 = document.createElement("div");
      if (t3.className = "time-plugin-container", this.rangePlugin) {
        const e3 = this.getStartInput();
        t3.appendChild(e3), this.picker.trigger("view", { view: "TimePluginInput", target: e3 });
        const i3 = this.getEndInput();
        t3.appendChild(i3), this.picker.trigger("view", { view: "TimePluginInput", target: i3 });
      } else {
        const e3 = this.getSingleInput();
        t3.appendChild(e3), this.picker.trigger("view", { view: "TimePluginInput", target: e3 });
      }
      i2.appendChild(t3), this.picker.trigger("view", { view: "TimePluginContainer", target: t3 });
    }
  }
  onInput(e2) {
    const i2 = e2.target;
    if (i2 instanceof HTMLInputElement && i2.classList.contains("time-plugin-input")) {
      const e3 = this.timePicked[i2.name] || new t(), [n2, s2] = i2.value.split(":");
      e3.setHours(Number(n2) || 0, Number(s2) || 0, 0, 0), this.picker.options.autoApply ? (this.timePicked[i2.name] = e3, this.picker.updateValues()) : this.timePrePicked[i2.name] = e3;
    }
  }
  onChange(e2) {
    const i2 = e2.target;
    if (i2 instanceof HTMLSelectElement && i2.classList.contains("time-plugin-custom-input")) {
      const e3 = /(\w+)\[(\w+)\]/, [, n2, s2] = i2.name.match(e3), o2 = Number(i2.value);
      let a2 = new t();
      switch (!this.picker.options.autoApply && this.timePrePicked[n2] instanceof Date ? a2 = this.timePrePicked[n2].clone() : this.timePicked[n2] instanceof Date && (a2 = this.timePicked[n2].clone()), s2) {
        case "HH":
          if (this.options.format12) {
            const t2 = i2.closest(".time-plugin-custom-block").querySelector(`select[name="${n2}[period]"]`).value, e4 = this.handleFormat12(t2, a2, o2);
            a2.setHours(e4.getHours(), e4.getMinutes(), e4.getSeconds(), 0);
          } else
            a2.setHours(o2, a2.getMinutes(), a2.getSeconds(), 0);
          break;
        case "mm":
          a2.setHours(a2.getHours(), o2, a2.getSeconds(), 0);
          break;
        case "ss":
          a2.setHours(a2.getHours(), a2.getMinutes(), o2, 0);
          break;
        case "period":
          if (this.options.format12) {
            const t2 = i2.closest(".time-plugin-custom-block").querySelector(`select[name="${n2}[HH]"]`).value, e4 = this.handleFormat12(i2.value, a2, Number(t2));
            a2.setHours(e4.getHours(), e4.getMinutes(), e4.getSeconds(), 0);
          }
      }
      if (this.picker.options.autoApply)
        this.timePicked[n2] = a2, this.picker.updateValues();
      else {
        this.timePrePicked[n2] = a2;
        const t2 = this.picker.ui.container.querySelector(".apply-button");
        if (this.rangePlugin) {
          const e4 = this.rangePlugin.options, i3 = this.picker.datePicked, n3 = e4.strict && 2 === i3.length || !e4.strict && i3.length > 0 || !i3.length && e4.strict && e4.startDate instanceof Date && e4.endDate instanceof Date || !i3.length && !e4.strict && (e4.startDate instanceof Date || e4.endDate instanceof Date);
          t2.disabled = !n3;
        } else
          this.picker.datePicked.length && (t2.disabled = false);
      }
    }
  }
  onClick(t2) {
    const e2 = t2.target;
    if (e2 instanceof HTMLElement) {
      const t3 = e2.closest(".unit");
      if (!(t3 instanceof HTMLElement))
        return;
      this.picker.isApplyButton(t3) && (Object.keys(this.timePicked).forEach((t4) => {
        this.timePrePicked[t4] instanceof Date && (this.timePicked[t4] = this.timePrePicked[t4].clone());
      }), this.picker.updateValues(), this.timePrePicked = { input: null, start: null, end: null }), this.picker.isCancelButton(t3) && (this.timePrePicked = { input: null, start: null, end: null }, this.picker.renderAll());
    }
  }
  setTime(t2) {
    const e2 = this.handleTimeString(t2);
    this.timePicked.input = e2.clone(), this.picker.renderAll(), this.picker.updateValues();
  }
  setStartTime(t2) {
    const e2 = this.handleTimeString(t2);
    this.timePicked.start = e2.clone(), this.picker.renderAll(), this.picker.updateValues();
  }
  setEndTime(t2) {
    const e2 = this.handleTimeString(t2);
    this.timePicked.end = e2.clone(), this.picker.renderAll(), this.picker.updateValues();
  }
  handleTimeString(e2) {
    const i2 = new t(), [n2, s2, o2] = e2.split(":").map((t2) => Number(t2)), a2 = n2 && !Number.isNaN(n2) ? n2 : 0, r2 = s2 && !Number.isNaN(s2) ? s2 : 0, c2 = o2 && !Number.isNaN(o2) ? o2 : 0;
    return i2.setHours(a2, r2, c2, 0), i2;
  }
  getDate() {
    if (this.picker.options.date instanceof Date) {
      const e2 = new t(this.picker.options.date, this.picker.options.format);
      if (this.timePicked.input instanceof Date) {
        const t2 = this.timePicked.input;
        e2.setHours(t2.getHours(), t2.getMinutes(), t2.getSeconds(), 0);
      }
      return e2;
    }
    return null;
  }
  getStartDate() {
    if (this.rangePlugin.options.startDate instanceof Date) {
      const e2 = new t(this.rangePlugin.options.startDate, this.picker.options.format);
      if (this.timePicked.start instanceof Date) {
        const t2 = this.timePicked.start;
        e2.setHours(t2.getHours(), t2.getMinutes(), t2.getSeconds(), 0);
      }
      return e2;
    }
    return null;
  }
  getEndDate() {
    if (this.rangePlugin.options.endDate instanceof Date) {
      const e2 = new t(this.rangePlugin.options.endDate, this.picker.options.format);
      if (this.timePicked.end instanceof Date) {
        const t2 = this.timePicked.end;
        e2.setHours(t2.getHours(), t2.getMinutes(), t2.getSeconds(), 0);
      }
      return e2;
    }
    return null;
  }
  getSingleInput() {
    return this.options.native ? this.getNativeInput("input") : this.getCustomInput("input");
  }
  getStartInput() {
    return this.options.native ? this.getNativeInput("start") : this.getCustomInput("start");
  }
  getEndInput() {
    return this.options.native ? this.getNativeInput("end") : this.getCustomInput("end");
  }
  getNativeInput(t2) {
    const e2 = document.createElement("input");
    e2.type = "time", e2.name = t2, e2.className = "time-plugin-input unit";
    const i2 = this.timePicked[t2];
    if (i2) {
      const t3 = `0${i2.getHours()}`.slice(-2), n2 = `0${i2.getMinutes()}`.slice(-2);
      e2.value = `${t3}:${n2}`;
    }
    return e2;
  }
  getCustomInput(t2) {
    const e2 = document.createElement("div");
    e2.className = "time-plugin-custom-block";
    const i2 = document.createElement("select");
    i2.className = "time-plugin-custom-input unit", i2.name = `${t2}[HH]`;
    const n2 = this.options.format12 ? 1 : 0, s2 = this.options.format12 ? 13 : 24;
    let o2 = null;
    !this.picker.options.autoApply && this.timePrePicked[t2] instanceof Date ? o2 = this.timePrePicked[t2].clone() : this.timePicked[t2] instanceof Date && (o2 = this.timePicked[t2].clone());
    for (let t3 = n2; t3 < s2; t3 += this.options.stepHours) {
      const e3 = document.createElement("option");
      e3.value = String(t3), e3.text = String(t3), o2 && (this.options.format12 ? (o2.getHours() % 12 ? o2.getHours() % 12 : 12) === t3 && (e3.selected = true) : o2.getHours() === t3 && (e3.selected = true)), i2.appendChild(e3);
    }
    e2.appendChild(i2);
    const a2 = document.createElement("select");
    a2.className = "time-plugin-custom-input unit", a2.name = `${t2}[mm]`;
    for (let t3 = 0; t3 < 60; t3 += this.options.stepMinutes) {
      const e3 = document.createElement("option");
      e3.value = `0${String(t3)}`.slice(-2), e3.text = `0${String(t3)}`.slice(-2), o2 && o2.getMinutes() === t3 && (e3.selected = true), a2.appendChild(e3);
    }
    if (e2.appendChild(a2), this.options.seconds) {
      const i3 = document.createElement("select");
      i3.className = "time-plugin-custom-input unit", i3.name = `${t2}[ss]`;
      const n3 = 60;
      for (let t3 = 0; t3 < n3; t3 += this.options.stepSeconds) {
        const e3 = document.createElement("option");
        e3.value = `0${String(t3)}`.slice(-2), e3.text = `0${String(t3)}`.slice(-2), o2 && o2.getSeconds() === t3 && (e3.selected = true), i3.appendChild(e3);
      }
      e2.appendChild(i3);
    }
    if (this.options.format12) {
      const i3 = document.createElement("select");
      i3.className = "time-plugin-custom-input unit", i3.name = `${t2}[period]`, ["AM", "PM"].forEach((t3) => {
        const e3 = document.createElement("option");
        e3.value = t3, e3.text = t3, o2 && "PM" === t3 && o2.getHours() >= 12 && (e3.selected = true), i3.appendChild(e3);
      }), e2.appendChild(i3);
    }
    return e2;
  }
  handleFormat12(t2, e2, i2) {
    const n2 = e2.clone();
    switch (t2) {
      case "AM":
        12 === i2 ? n2.setHours(0, n2.getMinutes(), n2.getSeconds(), 0) : n2.setHours(i2, n2.getMinutes(), n2.getSeconds(), 0);
        break;
      case "PM":
        12 !== i2 ? n2.setHours(i2 + 12, n2.getMinutes(), n2.getSeconds(), 0) : n2.setHours(i2, n2.getMinutes(), n2.getSeconds(), 0);
    }
    return n2;
  }
  parseValues() {
    if (this.rangePlugin) {
      if (this.rangePlugin.options.strict) {
        if (this.rangePlugin.options.startDate && this.rangePlugin.options.endDate) {
          const e2 = new t(this.rangePlugin.options.startDate, this.picker.options.format), i2 = new t(this.rangePlugin.options.endDate, this.picker.options.format);
          this.timePicked.start = e2.clone(), this.timePicked.end = i2.clone();
        }
      } else {
        if (this.rangePlugin.options.startDate) {
          const e2 = new t(this.rangePlugin.options.startDate, this.picker.options.format);
          this.timePicked.start = e2.clone();
        }
        if (this.rangePlugin.options.endDate) {
          const e2 = new t(this.rangePlugin.options.endDate, this.picker.options.format);
          this.timePicked.end = e2.clone();
        }
      }
      if (this.rangePlugin.options.elementEnd)
        if (this.rangePlugin.options.strict) {
          if (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length && this.rangePlugin.options.elementEnd instanceof HTMLInputElement && this.rangePlugin.options.elementEnd.value.length) {
            const e2 = new t(this.picker.options.element.value, this.picker.options.format), i2 = new t(this.rangePlugin.options.elementEnd.value, this.picker.options.format);
            this.timePicked.start = e2.clone(), this.timePicked.end = i2.clone();
          }
        } else {
          if (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length) {
            const e2 = new t(this.picker.options.element.value, this.picker.options.format);
            this.timePicked.start = e2.clone();
          }
          if (this.rangePlugin.options.elementEnd instanceof HTMLInputElement && this.rangePlugin.options.elementEnd.value.length) {
            const e2 = new t(this.rangePlugin.options.elementEnd.value, this.picker.options.format);
            this.timePicked.start = e2.clone();
          }
        }
      else if (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length) {
        const [e2, i2] = this.picker.options.element.value.split(this.rangePlugin.options.delimiter);
        if (this.rangePlugin.options.strict) {
          if (e2 && i2) {
            const n2 = new t(e2, this.picker.options.format), s2 = new t(i2, this.picker.options.format);
            this.timePicked.start = n2.clone(), this.timePicked.end = s2.clone();
          }
        } else {
          if (e2) {
            const i3 = new t(e2, this.picker.options.format);
            this.timePicked.start = i3.clone();
          }
          if (i2) {
            const e3 = new t(i2, this.picker.options.format);
            this.timePicked.start = e3.clone();
          }
        }
      }
    } else {
      if (this.picker.options.date) {
        const e2 = new t(this.picker.options.date, this.picker.options.format);
        this.timePicked.input = e2.clone();
      }
      if (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length) {
        const e2 = new t(this.picker.options.element.value, this.picker.options.format);
        this.timePicked.input = e2.clone();
      }
    }
  }
};
var h = class extends o {
  constructor() {
    super(...arguments);
    __publicField(this, "docElement", null);
    __publicField(this, "rangePlugin");
    __publicField(this, "binds", { onView: this.onView.bind(this), onKeydown: this.onKeydown.bind(this) });
    __publicField(this, "options", { unitIndex: 1, dayIndex: 2 });
  }
  getName() {
    return "KbdPlugin";
  }
  onAttach() {
    const t2 = this.picker.options.element, e2 = t2.getBoundingClientRect();
    if (this.docElement = document.createElement("span"), this.docElement.style.position = "absolute", this.docElement.style.top = `${t2.offsetTop}px`, this.docElement.style.left = t2.offsetLeft + e2.width - 25 + "px", this.docElement.attachShadow({ mode: "open" }), this.options.html)
      this.docElement.shadowRoot.innerHTML = this.options.html;
    else {
      const t3 = `
      <style>
      button {
        border: none;
        background: transparent;
        font-size: ${window.getComputedStyle(this.picker.options.element).fontSize};
      }
      </style>

      <button>&#128197;</button>
      `;
      this.docElement.shadowRoot.innerHTML = t3;
    }
    const i2 = this.docElement.shadowRoot.querySelector("button");
    i2 && (i2.addEventListener("click", (t3) => {
      t3.preventDefault(), this.picker.show({ target: this.picker.options.element });
    }, { capture: true }), i2.addEventListener("keydown", (t3) => {
      "Escape" === t3.code && this.picker.hide();
    }, { capture: true })), this.picker.options.element.after(this.docElement), this.picker.on("view", this.binds.onView), this.picker.on("keydown", this.binds.onKeydown);
  }
  onDetach() {
    this.docElement && this.docElement.isConnected && this.docElement.remove(), this.picker.off("view", this.binds.onView), this.picker.off("keydown", this.binds.onKeydown);
  }
  onView(t2) {
    const { view: e2, target: i2 } = t2.detail;
    i2 && "querySelector" in i2 && ("CalendarDay" !== e2 || ["locked", "not-available"].some((t3) => i2.classList.contains(t3)) ? [...i2.querySelectorAll(".unit:not(.day)")].forEach((t3) => t3.tabIndex = this.options.unitIndex) : i2.tabIndex = this.options.dayIndex);
  }
  onKeydown(t2) {
    switch (this.onMouseEnter(t2), t2.code) {
      case "ArrowUp":
      case "ArrowDown":
        this.verticalMove(t2);
        break;
      case "ArrowLeft":
      case "ArrowRight":
        this.horizontalMove(t2);
        break;
      case "Enter":
      case "Space":
        this.handleEnter(t2);
        break;
      case "Escape":
        this.picker.hide();
    }
  }
  findAllowableDaySibling(t2, e2, i2) {
    const n2 = Array.from(t2.querySelectorAll(`.day[tabindex="${this.options.dayIndex}"]`)), s2 = n2.indexOf(e2);
    return n2.filter((t3, e3) => i2(e3, s2) && t3.tabIndex === this.options.dayIndex)[0];
  }
  changeMonth(t2) {
    const e2 = { ArrowLeft: "previous", ArrowRight: "next" }, i2 = this.picker.ui.container.querySelector(`.${e2[t2.code]}-button[tabindex="${this.options.unitIndex}"]`);
    i2 && !i2.parentElement.classList.contains(`no-${e2[t2.code]}-month`) && (i2.dispatchEvent(new Event("click", { bubbles: true })), setTimeout(() => {
      let e3 = null;
      switch (t2.code) {
        case "ArrowLeft":
          const t3 = this.picker.ui.container.querySelectorAll(`.day[tabindex="${this.options.dayIndex}"]`);
          e3 = t3[t3.length - 1];
          break;
        case "ArrowRight":
          e3 = this.picker.ui.container.querySelector(`.day[tabindex="${this.options.dayIndex}"]`);
      }
      e3 && e3.focus();
    }));
  }
  verticalMove(t2) {
    const e2 = t2.target;
    if (e2.classList.contains("day")) {
      t2.preventDefault();
      const i2 = this.findAllowableDaySibling(this.picker.ui.container, e2, (e3, i3) => e3 === ("ArrowUp" === t2.code ? i3 - 7 : i3 + 7));
      i2 && i2.focus();
    }
  }
  horizontalMove(t2) {
    const e2 = t2.target;
    if (e2.classList.contains("day")) {
      t2.preventDefault();
      const i2 = this.findAllowableDaySibling(this.picker.ui.container, e2, (e3, i3) => e3 === ("ArrowLeft" === t2.code ? i3 - 1 : i3 + 1));
      i2 ? i2.focus() : this.changeMonth(t2);
    }
  }
  handleEnter(t2) {
    const e2 = t2.target;
    e2.classList.contains("day") && (t2.preventDefault(), e2.dispatchEvent(new Event("click", { bubbles: true })), setTimeout(() => {
      if (this.rangePlugin = this.picker.PluginManager.getInstance("RangePlugin"), this.rangePlugin || !this.picker.options.autoApply) {
        const t3 = this.picker.ui.container.querySelector(".day.selected");
        t3 && setTimeout(() => {
          t3.focus();
        });
      }
    }));
  }
  onMouseEnter(t2) {
    t2.target.classList.contains("day") && setTimeout(() => {
      const t3 = this.picker.ui.shadowRoot.activeElement;
      t3 && t3.dispatchEvent(new Event("mouseenter", { bubbles: true }));
    });
  }
};
var d = class extends o {
  constructor() {
    super(...arguments);
    __publicField(this, "rangePlugin");
    __publicField(this, "lockPlugin");
    __publicField(this, "priority", 10);
    __publicField(this, "binds", { onView: this.onView.bind(this), onColorScheme: this.onColorScheme.bind(this) });
    __publicField(this, "options", { dropdown: { months: false, years: false, minYear: 1950, maxYear: null }, darkMode: true, locale: { resetButton: '<svg xmlns="http://www.w3.org/2000/svg" height="24" width="24"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/></svg>' } });
    __publicField(this, "matchMedia");
  }
  getName() {
    return "AmpPlugin";
  }
  onAttach() {
    this.options.darkMode && window && "matchMedia" in window && (this.matchMedia = window.matchMedia("(prefers-color-scheme: dark)"), this.matchMedia.matches && (this.picker.ui.container.dataset.theme = "dark"), this.matchMedia.addEventListener("change", this.binds.onColorScheme)), this.options.weekNumbers && this.picker.ui.container.classList.add("week-numbers"), this.picker.on("view", this.binds.onView);
  }
  onDetach() {
    this.options.darkMode && window && "matchMedia" in window && this.matchMedia.removeEventListener("change", this.binds.onColorScheme), this.picker.ui.container.removeAttribute("data-theme"), this.picker.ui.container.classList.remove("week-numbers"), this.picker.off("view", this.binds.onView);
  }
  onView(t2) {
    this.lockPlugin = this.picker.PluginManager.getInstance("LockPlugin"), this.rangePlugin = this.picker.PluginManager.getInstance("RangePlugin"), this.handleDropdown(t2), this.handleResetButton(t2), this.handleWeekNumbers(t2);
  }
  onColorScheme(t2) {
    const e2 = t2.matches ? "dark" : "light";
    this.picker.ui.container.dataset.theme = e2;
  }
  handleDropdown(e2) {
    const { view: i2, target: n2, date: s2, index: o2 } = e2.detail;
    if ("CalendarHeader" === i2) {
      const e3 = n2.querySelector(".month-name");
      if (this.options.dropdown.months) {
        e3.childNodes[0].remove();
        const i3 = document.createElement("select");
        i3.className = "month-name--select month-name--dropdown";
        for (let e4 = 0; e4 < 12; e4 += 1) {
          const n3 = document.createElement("option"), o3 = new t(new Date(s2.getFullYear(), e4, 2, 0, 0, 0)), a2 = new t(new Date(s2.getFullYear(), e4, 1, 0, 0, 0));
          n3.value = String(e4), n3.text = o3.toLocaleString(this.picker.options.lang, { month: "long" }), this.lockPlugin && (n3.disabled = this.lockPlugin.options.minDate && a2.isBefore(new t(this.lockPlugin.options.minDate), "month") || this.lockPlugin.options.maxDate && a2.isAfter(new t(this.lockPlugin.options.maxDate), "month")), n3.selected = a2.getMonth() === s2.getMonth(), i3.appendChild(n3);
        }
        i3.addEventListener("change", (t2) => {
          const e4 = t2.target;
          this.picker.calendars[0].setDate(1), this.picker.calendars[0].setMonth(Number(e4.value)), this.picker.renderAll();
        }), e3.prepend(i3);
      }
      if (this.options.dropdown.years) {
        e3.childNodes[1].remove();
        const i3 = document.createElement("select");
        i3.className = "month-name--select";
        const n3 = this.options.dropdown.minYear, o3 = this.options.dropdown.maxYear ? this.options.dropdown.maxYear : new Date().getFullYear();
        if (s2.getFullYear() > o3) {
          const t2 = document.createElement("option");
          t2.value = String(s2.getFullYear()), t2.text = String(s2.getFullYear()), t2.selected = true, t2.disabled = true, i3.appendChild(t2);
        }
        for (let e4 = o3; e4 >= n3; e4 -= 1) {
          const n4 = document.createElement("option"), o4 = new t(new Date(e4, 0, 1, 0, 0, 0));
          n4.value = String(e4), n4.text = String(e4), this.lockPlugin && (n4.disabled = this.lockPlugin.options.minDate && o4.isBefore(new t(this.lockPlugin.options.minDate), "year") || this.lockPlugin.options.maxDate && o4.isAfter(new t(this.lockPlugin.options.maxDate), "year")), n4.selected = s2.getFullYear() === e4, i3.appendChild(n4);
        }
        if (s2.getFullYear() < n3) {
          const t2 = document.createElement("option");
          t2.value = String(s2.getFullYear()), t2.text = String(s2.getFullYear()), t2.selected = true, t2.disabled = true, i3.appendChild(t2);
        }
        if ("asc" === this.options.dropdown.years) {
          const t2 = Array.prototype.slice.call(i3.childNodes).reverse();
          i3.innerHTML = "", t2.forEach((t3) => {
            t3.innerHTML = t3.value, i3.appendChild(t3);
          });
        }
        i3.addEventListener("change", (t2) => {
          const e4 = t2.target;
          this.picker.calendars[0].setFullYear(Number(e4.value)), this.picker.renderAll();
        }), e3.appendChild(i3);
      }
    }
  }
  handleResetButton(t2) {
    const { view: e2, target: i2 } = t2.detail;
    if ("CalendarHeader" === e2 && this.options.resetButton) {
      const t3 = document.createElement("button");
      t3.className = "reset-button unit", t3.innerHTML = this.options.locale.resetButton, t3.addEventListener("click", (t4) => {
        t4.preventDefault();
        let e3 = true;
        "function" == typeof this.options.resetButton && (e3 = this.options.resetButton.call(this)), e3 && this.picker.clear();
      }), i2.appendChild(t3);
    }
  }
  handleWeekNumbers(e2) {
    if (this.options.weekNumbers) {
      const { view: i2, target: n2 } = e2.detail;
      if ("CalendarDayNames" === i2) {
        const t2 = document.createElement("div");
        t2.className = "wnum-header", t2.innerHTML = "Wk", n2.prepend(t2);
      }
      "CalendarDays" === i2 && [...n2.children].forEach((e3, i3) => {
        if (0 === i3 || i3 % 7 == 0) {
          let i4;
          if (e3.classList.contains("day"))
            i4 = new t(e3.dataset.time);
          else {
            const e4 = n2.querySelector(".day");
            i4 = new t(e4.dataset.time);
          }
          let s2 = i4.getWeek(this.picker.options.firstDay);
          53 === s2 && 0 === i4.getMonth() && (s2 = "53/1");
          const o2 = document.createElement("div");
          o2.className = "wnum-item", o2.innerHTML = String(s2), n2.insertBefore(o2, e3);
        }
      });
    }
  }
};
export {
  d as AmpPlugin,
  t as DateTime,
  h as KbdPlugin,
  a as LockPlugin,
  r as PresetPlugin,
  c as RangePlugin,
  l as TimePlugin,
  n as create,
  s as easepick
};
//# sourceMappingURL=@easepick_bundle.js.map
